Arguments:
- av[0] titulo do programa
- av[1] number_of_philosophers
- av[2] time_to_die
- av[3] time_to_eat
- av[4] time_to_sleep
- av[5] number_of_times_each_philosopher_must_eat (optional)
*/

...

/*
FORK MUTEX CONCURRENCY (LOCKING AT THE SAME TIME STALEMATE)

-> fork concurrency problem
cada 1 pega num fork e fica so c um e morrem todos
..
algo estranho se passa c o last_ate, ou tou a aceder
ao filosofo / indice errado
(V) -- acrescentar aquilo ao t_person struct
(V) -- associar p e f forks e mutexes de cada person aos respetivos membros
da struct all
(V) -- mudar os pointers fork e mutex na eating status
*/

/*
ATOMIC OPPS

para garantir uma resposta mais rapida, sugeriram sinchronization
mechanisms como atomic operations
*/

escrever a documentacao so no fim porque pode haver mudancas e coisas que escrevo
mal a meio

-> smaller usleep() timers
corre normalmente, simplesmente tenho death_msg checkers em todo o lado
que nao correm mais mensagem nenhuma caso alguem morra

-> testar arg opcional
parece estar top

-> negative hunger values;
-> use join instead of detach;
/----------------------------------------------------------------/
PROBLEM 1: DEADLOCK SITUATION (getting both forks simultaneously)

i solved that with:
- micro usleep() delay in each thread initialization; (retired)
- drop fork and try again mechanism;
- creation of uneven numbered philosophers first, and only then creating the
even ones

Apparently, this situation has been resolved (for now);

/----------------------------------------------------------------/
PROBLEM 2: NO DEATHS PROBLEM (no philosophers die ever)

eu largava logo os mutexes enquanto ele ainda tava a comer e comiam
todos ao mesmo tempo, not really a problem
/----------------------------------------------------------------/
current:

eles tem que segurar os garfos e os mutexes enquanto comem oh burro do crl
ja mudei
usar o visualizer
agora ate acho que o delay e problema porque
nao preciso de definir uma "ordem"/hierarquia para quem esta ha mais tempo sem comer
porque o scheduler e os mutexes ja fazem isso automaticamente
eu so preciso é de eliminar aquele pequenito delay agora
sera a thread concorrente? que o tempo registado a pedir o tempo, ou as mensagens,
ou wtv. ok agora tenho e que reduzir o delay

delay get_time
é sempre +1ms, -1ms... e eu auto-reprovo-me por causa disso
mas como prevenir?

/----------------------------------------------------------------/
DELAY?

eu noto o timer da get_time a ir ganhando algum delay
no entanto, o delay da hunger vai levando reset e perde tracao

segundo a logica, o delay devera ser de 10ms para ultrapassar os tempos e
algum philo morrer. eu mesmo no get_time demoro prai uns 11/12 segundos a
atingir 10ms de delay, é pouco

get_time_reads ganha delay
last_ate ganha delay
hunger nao ganha delay
hunger deveria ganhar delay para ultrapassar o time_to_die;
para isso, last_ate nao deveria ganhar delay

mas pela logica, nao faz sentido hunger ir ganhando delay
ou seja, vai ficando mais dificil comer?
ou, em vez de delay, deve morrer logo? acho que sim, deve ser face value

o delay pode ser:
- delay natural de carga de CPU
- delay do pedido da funcao de tempo
- delay no mutex de printar

Paralellism as a solution for function and I/O overload

- criar threads para ajudar com algo
- gerir melhor timers com mutexes
- gerir melhor a questao da retry to eat e evitar aqueles loops infinitos
(ou se calhar diminuir a carga de funçoes em geral)

DEADLOCK MANAGEMENT?

lembrei-me agora que pode ser a propria maneira como eu faco gestao do
deadlock que pode fazer com que ninguem morra. se calhar é suposto criar uma
"ordem" para eles comerem, em vez do mecanismo de pegar/largar ate dar
no entanto, se assim for, vai contra as proprias regras do enunciado. nenhum
filosofo pode saber um do outro nem comunicar

--------------------------------------------------------------------------

a criacao das threads em si nao é muito regular
threads nao começam na ordem em que as crias
a funcao usleep em si tambem nao e muito regular
unica maneira é mesmo criar mecanismos dos philos falarem entre si
ou haver algum tipo de informacao previa extra sobre ordens de comidas

impares comem primeiro
pares comem depois

criam todas as threads, esperam, e só depois é que começam todos
tipo um int *start = len do int *forks
condicao partida para inicializar threads é todos os starts = 1

int *start;
start = malloc(all->philo_num + 1 * sizeof(int));
start[all->philo_num] = '\0';
int i = -1;
while (all->start[++i] != '\0')
    all->start[i] = 0;

void    start_race()
int go;
int i;
go = 0;
i = -1;
all->start[philo_num] = 1;
while (go == 0) {
    i = -1;
    while (all->start[i] == 1)
        ;
    if ([] == '\0')
        go = 1;
    //break;
}
----------------------------
na minha opiniao, o problema é menos de delay do codigo e mais de
dificuldade do OS gerir tantas threads ao mm tempo
nao é suposto funcionar 100% das vezes
however, eu agr tenho um erro de numeros impares
tenho que arranjar maneira de gerir como escolher quem come, mas
eu nao queria comunicar filosofos entre si nem comparar
hunger levels

data races entre starvation, overcharge de threads.. talvez eliminando
a starvation eu consiga melhorar o funcionamento

transformar starvation em check_hunger antes de cada get_time ou death_msg
ou isso

- testar tudo;
- caso de, substituir no github e guardar ja
- data races
- valgrind
- normalmente
- ver se consigo entregar ja hoje